"use strict";
/*
 * Copyright 2022 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
// This is patched generated by wasm-pack file
var marine_js_js_1 = require("./snippets/marine-js-6faa67b8af9cc173/marine-js.js");
function init(module) {
    return __awaiter(this, void 0, void 0, function () {
        function getObject(idx) { return heap[idx]; }
        function dropObject(idx) {
            if (idx < 36)
                return;
            heap[idx] = heap_next;
            heap_next = idx;
        }
        function takeObject(idx) {
            var ret = getObject(idx);
            dropObject(idx);
            return ret;
        }
        function getUint8Memory0() {
            if (cachedUint8Memory0.byteLength === 0) {
                cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
            }
            return cachedUint8Memory0;
        }
        function getStringFromWasm0(ptr, len) {
            return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
        }
        function addHeapObject(obj) {
            if (heap_next === heap.length)
                heap.push(heap.length + 1);
            var idx = heap_next;
            heap_next = heap[idx];
            heap[idx] = obj;
            return idx;
        }
        function passStringToWasm0(arg, malloc, realloc) {
            if (realloc === undefined) {
                var buf = cachedTextEncoder.encode(arg);
                var ptr_1 = malloc(buf.length);
                getUint8Memory0().subarray(ptr_1, ptr_1 + buf.length).set(buf);
                WASM_VECTOR_LEN = buf.length;
                return ptr_1;
            }
            var len = arg.length;
            var ptr = malloc(len);
            var mem = getUint8Memory0();
            var offset = 0;
            for (; offset < len; offset++) {
                var code = arg.charCodeAt(offset);
                if (code > 0x7F)
                    break;
                mem[ptr + offset] = code;
            }
            if (offset !== len) {
                if (offset !== 0) {
                    arg = arg.slice(offset);
                }
                ptr = realloc(ptr, len, len = offset + arg.length * 3);
                var view = getUint8Memory0().subarray(ptr + offset, ptr + len);
                var ret = encodeString(arg, view);
                offset += ret.written;
            }
            WASM_VECTOR_LEN = offset;
            return ptr;
        }
        function getInt32Memory0() {
            if (cachedInt32Memory0.byteLength === 0) {
                cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
            }
            return cachedInt32Memory0;
        }
        function passArray8ToWasm0(arg, malloc) {
            var ptr = malloc(arg.length * 1);
            getUint8Memory0().set(arg, ptr / 1);
            WASM_VECTOR_LEN = arg.length;
            return ptr;
        }
        /**
         * Registers a module inside web-runtime.
         *
         * # Arguments
         *
         * * `name` - name of module to register
         * * `wit_section_bytes` - bytes of "interface-types" custom section from wasm file
         * * `instance` - `WebAssembly::Instance` made from target wasm file
         *
         * # Return value
         *
         * JSON object with field "error". If error is empty, module is registered.
         * otherwise, it contains error message.
         * @param {string} name
         * @param {Uint8Array} wit_section_bytes
         * @param {any} wasm_instance
         * @returns {string}
         */
        function register_module(name, wit_section_bytes, wasm_instance) {
            try {
                var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                var ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                var len0 = WASM_VECTOR_LEN;
                var ptr1 = passArray8ToWasm0(wit_section_bytes, wasm.__wbindgen_malloc);
                var len1 = WASM_VECTOR_LEN;
                wasm.register_module(retptr, ptr0, len0, ptr1, len1, addHeapObject(wasm_instance));
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                return getStringFromWasm0(r0, r1);
            }
            finally {
                wasm.__wbindgen_add_to_stack_pointer(16);
                wasm.__wbindgen_free(r0, r1);
            }
        }
        /**
         *  Calls a function from a module.
         *
         * # Arguments
         *
         * * module_name - name of registered module
         * * function_name - name of the function to call
         * * args - JSON array of function arguments
         *
         * # Return value
         *
         * JSON object with fields "error" and "result". If "error" is empty string,
         * "result" contains a function return value. Otherwise, "error" contains error message.
         * @param {string} module_name
         * @param {string} function_name
         * @param {string} args
         * @returns {string}
         */
        function call_module(module_name, function_name, args) {
            try {
                var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                var ptr0 = passStringToWasm0(module_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                var len0 = WASM_VECTOR_LEN;
                var ptr1 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                var len1 = WASM_VECTOR_LEN;
                var ptr2 = passStringToWasm0(args, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                var len2 = WASM_VECTOR_LEN;
                wasm.call_module(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                return getStringFromWasm0(r0, r1);
            }
            finally {
                wasm.__wbindgen_add_to_stack_pointer(16);
                wasm.__wbindgen_free(r0, r1);
            }
        }
        function getArrayU8FromWasm0(ptr, len) {
            return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
        }
        function getImports() {
            var imports = {};
            imports.wbg = {};
            imports.wbg.__wbg_writebyterange_0c59aabc2aad1210 = function (arg0, arg1, arg2, arg3) {
                (0, marine_js_js_1.write_byte_range)(getObject(arg0), arg1 >>> 0, getArrayU8FromWasm0(arg2, arg3));
            };
            imports.wbg.__wbg_readbyte_0b96cd62e4c1af25 = function (arg0, arg1) {
                var ret = (0, marine_js_js_1.read_byte)(getObject(arg0), arg1 >>> 0);
                return ret;
            };
            imports.wbg.__wbg_readbyterange_6def5970b1aebf61 = function (arg0, arg1, arg2, arg3) {
                (0, marine_js_js_1.read_byte_range)(getObject(arg0), arg1 >>> 0, getArrayU8FromWasm0(arg2, arg3));
            };
            imports.wbg.__wbg_getmemorysize_16d792c547469ba4 = function (arg0) {
                var ret = (0, marine_js_js_1.get_memory_size)(getObject(arg0));
                return ret;
            };
            imports.wbg.__wbg_new_abda76e883ba8a5f = function () {
                var ret = new Error();
                return addHeapObject(ret);
            };
            imports.wbg.__wbg_stack_658279fe44541cf6 = function (arg0, arg1) {
                var ret = getObject(arg1).stack;
                var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                var len0 = WASM_VECTOR_LEN;
                getInt32Memory0()[arg0 / 4 + 1] = len0;
                getInt32Memory0()[arg0 / 4 + 0] = ptr0;
            };
            imports.wbg.__wbg_error_f851667af71bcfc6 = function (arg0, arg1) {
                try {
                    console.error(getStringFromWasm0(arg0, arg1));
                }
                finally {
                    wasm.__wbindgen_free(arg0, arg1);
                }
            };
            imports.wbg.__wbindgen_object_drop_ref = function (arg0) {
                takeObject(arg0);
            };
            imports.wbg.__wbg_writebyte_111fe93c2b0126fe = function (arg0, arg1, arg2) {
                (0, marine_js_js_1.write_byte)(getObject(arg0), arg1 >>> 0, arg2);
            };
            imports.wbg.__wbg_callexport_633630b9132e20a4 = function (arg0, arg1, arg2, arg3, arg4, arg5) {
                var ret = (0, marine_js_js_1.call_export)(getObject(arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5));
                var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                var len0 = WASM_VECTOR_LEN;
                getInt32Memory0()[arg0 / 4 + 1] = len0;
                getInt32Memory0()[arg0 / 4 + 0] = ptr0;
            };
            return imports;
        }
        function initMemory(imports, maybe_memory) {
        }
        function finalizeInit(instance, module) {
            wasm = instance.exports;
            init.__wbindgen_wasm_module = module;
            cachedInt32Memory0 = new Int32Array();
            cachedUint8Memory0 = new Uint8Array();
            // calls main() function. Used to set up
            wasm.__wbindgen_start();
            return wasm;
        }
        function init(wasmModule) {
            return __awaiter(this, void 0, void 0, function () {
                var imports, instance;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            imports = getImports();
                            initMemory(imports);
                            return [4 /*yield*/, WebAssembly.instantiate(wasmModule, imports)];
                        case 1:
                            instance = _a.sent();
                            return [2 /*return*/, finalizeInit(instance, module)];
                    }
                });
            });
        }
        var wasm, heap, heap_next, cachedTextDecoder, cachedUint8Memory0, WASM_VECTOR_LEN, cachedTextEncoder, encodeString, cachedInt32Memory0;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    heap = new Array(32).fill(undefined);
                    heap.push(undefined, null, true, false);
                    heap_next = heap.length;
                    cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });
                    cachedTextDecoder.decode();
                    cachedUint8Memory0 = new Uint8Array();
                    WASM_VECTOR_LEN = 0;
                    cachedTextEncoder = new TextEncoder('utf-8');
                    encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
                        ? function (arg, view) {
                            return cachedTextEncoder.encodeInto(arg, view);
                        }
                        : function (arg, view) {
                            var buf = cachedTextEncoder.encode(arg);
                            view.set(buf);
                            return {
                                read: arg.length,
                                written: buf.length
                            };
                        });
                    cachedInt32Memory0 = new Int32Array();
                    return [4 /*yield*/, init(module)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, {
                            wasm: wasm,
                            register_module: register_module,
                            call_module: call_module,
                        }];
            }
        });
    });
}
exports.init = init;
//# sourceMappingURL=marine_js.js.map