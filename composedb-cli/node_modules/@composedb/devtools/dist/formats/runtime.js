function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { camelCase, pascalCase } from 'change-case';
import { JsonReference } from 'json-ptr';
import { SCALAR_RUNTIME_TYPES } from '../schema/scalars.js';
import { viewDefinitionToRuntime } from '../utils.js';
/** @internal */ export function getName(base, prefix = '') {
    const withCase = pascalCase(base);
    return withCase.startsWith(prefix) ? withCase : prefix + withCase;
}
/** @internal */ export function getStringScalarType(schema) {
    return SCALAR_RUNTIME_TYPES[schema.title] ?? 'string';
}
var _commonEmbeds = /*#__PURE__*/ new WeakMap(), _modelName = /*#__PURE__*/ new WeakMap(), _modelSchema = /*#__PURE__*/ new WeakMap(), _modelViews = /*#__PURE__*/ new WeakMap(), _objects = /*#__PURE__*/ new WeakMap(), _enums = /*#__PURE__*/ new WeakMap(), _unions = /*#__PURE__*/ new WeakMap();
/** @internal */ export class RuntimeModelBuilder {
    build() {
        const modelObject = this._buildObject(_classPrivateFieldGet(this, _modelSchema));
        _classPrivateFieldGet(this, _objects)[_classPrivateFieldGet(this, _modelName)] = modelObject;
        // TODO (post-MVP): build relations
        this._buildViews(modelObject, _classPrivateFieldGet(this, _modelViews));
        return {
            objects: _classPrivateFieldGet(this, _objects),
            enums: _classPrivateFieldGet(this, _enums),
            unions: _classPrivateFieldGet(this, _unions)
        };
    }
    _getName(schema, params, isReference = false) {
        return isReference && typeof schema.title === 'string' ? _classPrivateFieldGet(this, _commonEmbeds).includes(schema.title) ? schema.title : getName(schema.title, _classPrivateFieldGet(this, _modelName)) : params.ownName ?? _classPrivateFieldGet(this, _modelName);
    }
    _getReferenceSchema(reference) {
        const ref = new JsonReference(reference);
        const schema = ref.resolve(_classPrivateFieldGet(this, _modelSchema));
        if (schema == null) {
            throw new Error(`Missing reference: ${reference}`);
        }
        return schema;
    }
    _buildObject(schema, params = {}) {
        const ownName = this._getName(schema, params);
        const requiredProps = schema.required ?? [];
        const fields = {};
        for (const [propKey, propSchema] of Object.entries(schema.properties ?? {})){
            fields[propKey] = this._buildObjectField(propSchema, {
                ownName: propKey,
                parentName: ownName,
                required: requiredProps.includes(propKey)
            });
        }
        return fields;
    }
    _buildObjectField(schema, params = {}) {
        if (schema.$ref != null) {
            return this._buildReferenceSchema(schema.$ref, params);
        }
        switch(schema.type){
            case 'array':
                return this._buildList(schema, params);
            case 'object':
                return this._buildObjectReferenceField(schema, params);
            default:
                return this._buildScalar(schema, params);
        }
    }
    _buildList(schema, params = {}) {
        if (typeof schema.items !== 'object' || Array.isArray(schema.items)) {
            throw new Error('Unsupported items schema in array');
        }
        const required = params.required ?? false;
        const items = schema.items;
        if (items.$ref != null) {
            return {
                type: 'list',
                required,
                item: this._buildListReference(items.$ref, params)
            };
        }
        if (items.type == null) {
            throw new Error('Missing schema $ref or type for array items');
        }
        let item;
        switch(items.type){
            case 'array':
                throw new Error('Unsupported array in array');
            case 'object':
                item = this._buildObjectReferenceField(items, params);
                break;
            default:
                item = this._buildScalar(items, params);
                break;
        }
        return {
            type: 'list',
            required,
            item
        };
    }
    _buildListReference(reference, params = {}) {
        const schema = this._getReferenceSchema(reference);
        switch(schema.type){
            case 'array':
                throw new Error('Unsupported array in array reference');
            case 'object':
                return this._buildObjectReferenceField(schema, params);
            case 'string':
                return schema.enum != null && schema.title != null ? this._buildEnumReferenceField(schema) : this._buildScalar(schema, params);
            default:
                return this._buildScalar(schema, params);
        }
    }
    _buildObjectReferenceField(schema, params = {}) {
        const ownName = this._getName(schema, params, true);
        if (_classPrivateFieldGet(this, _objects)[ownName] == null) {
            _classPrivateFieldGet(this, _objects)[ownName] = this._buildObject(schema, {
                ...params,
                ownName
            });
        }
        return {
            type: 'reference',
            refType: 'object',
            refName: ownName,
            required: params.required ?? false
        };
    }
    _buildEnumReferenceField(schema, params = {}) {
        const ownName = this._getName(schema, params, true);
        if (_classPrivateFieldGet(this, _enums)[ownName] == null) {
            _classPrivateFieldGet(this, _enums)[ownName] = schema.enum;
        }
        return {
            type: 'reference',
            refType: 'enum',
            refName: ownName,
            required: params.required ?? false
        };
    }
    _buildReferenceSchema(reference, params = {}) {
        const schema = this._getReferenceSchema(reference);
        switch(schema.type){
            case 'array':
                return this._buildList(schema, params);
            case 'object':
                return this._buildObjectReferenceField(schema, params);
            case 'string':
                return schema.enum != null && schema.title != null ? this._buildEnumReferenceField(schema) : this._buildScalar(schema, params);
            default:
                return this._buildScalar(schema, params);
        }
    }
    _buildScalar(schema, params = {}) {
        if (schema.type == null) {
            throw new Error('Missing scalar type');
        }
        const required = params.required ?? false;
        switch(schema.type){
            case 'boolean':
            case 'integer':
                return {
                    type: schema.type,
                    required
                };
            case 'number':
                return {
                    type: 'float',
                    required
                };
            case 'string':
                return {
                    type: getStringScalarType(schema),
                    required
                };
        }
    }
    _buildViews(object, views = {}) {
        for (const [key, view] of Object.entries(views)){
            object[key] = viewDefinitionToRuntime(view);
        }
    }
    constructor(params){
        _classPrivateFieldInit(this, _commonEmbeds, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _modelName, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _modelSchema, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _modelViews, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _objects, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInit(this, _enums, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInit(this, _unions, {
            writable: true,
            value: {}
        });
        _classPrivateFieldSet(this, _commonEmbeds, params.commonEmbeds ?? []);
        _classPrivateFieldSet(this, _modelName, params.name);
        _classPrivateFieldSet(this, _modelSchema, params.definition.schema);
        _classPrivateFieldSet(this, _modelViews, params.views);
    }
}
/** @internal */ export function createRuntimeDefinition(definition) {
    const runtime = {
        models: {},
        objects: {},
        enums: {},
        accountData: {}
    };
    for (const [modelID, modelDefinition] of Object.entries(definition.models)){
        const modelName = definition.aliases?.[modelID] ?? modelDefinition.name;
        // Add name to model metadata mapping
        runtime.models[modelName] = {
            id: modelID,
            accountRelation: modelDefinition.accountRelation
        };
        // Extract objects, enums, relations and views from model schema
        const modelViews = modelDefinition.views ?? {};
        const compositeModelViews = definition.views?.models?.[modelID] ?? {};
        const modelBuilder = new RuntimeModelBuilder({
            commonEmbeds: definition.commonEmbeds,
            name: modelName,
            definition: modelDefinition,
            views: {
                ...modelViews,
                ...compositeModelViews
            }
        });
        const builtModel = modelBuilder.build();
        // Inject extracted types to runtime definition
        Object.assign(runtime.objects, builtModel.objects);
        Object.assign(runtime.enums, builtModel.enums);
        // Attach entry-point to account store based on relation type
        if (modelDefinition.accountRelation != null) {
            const key = camelCase(modelName);
            const relationType = modelDefinition.accountRelation.type;
            if (relationType === 'single') {
                runtime.accountData[key] = {
                    type: 'node',
                    name: modelName
                };
            // @ts-ignore TS2367, should be unnecessary check based on type definition but more types
            // could be added later
            } else if (relationType === 'list') {
                runtime.accountData[key + 'List'] = {
                    type: 'connection',
                    name: modelName
                };
            } else {
                throw new Error(`Unsupported account relation type: ${relationType}`);
            }
        }
    }
    // TODO: handle definition.views for models relations, accountData and root view
    return runtime;
}
