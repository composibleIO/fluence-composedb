import type { CeramicApi } from '@ceramicnetwork/common';
import type { CompositeViewsDefinition, EncodedCompositeDefinition, InternalCompositeDefinition, RuntimeCompositeDefinition, StreamCommits } from '@composedb/types';
declare type StrictCompositeDefinition = Required<InternalCompositeDefinition>;
/** @internal */
export declare function setDefinitionAliases(definition: StrictCompositeDefinition, aliases: Record<string, string>, replace?: boolean): StrictCompositeDefinition;
/** @internal */
export declare function setDefinitionCommonEmbeds(definition: StrictCompositeDefinition, names: Iterable<string>, replace?: boolean): StrictCompositeDefinition;
/** @internal */
export declare function setDefinitionViews(definition: StrictCompositeDefinition, views: CompositeViewsDefinition, replace?: boolean): StrictCompositeDefinition;
/**
 * Composite instance creation parameters.
 */
export declare type CompositeParams = {
    /**
     * Model streams commits, that can be pushed to any Ceramic node to ensure the Model streams
     * used by a composite are available.
     */
    commits: Record<string, StreamCommits>;
    /**
     * Internal metadata describing the composite.
     */
    definition: InternalCompositeDefinition;
};
/**
 * Supported composite input when comparing or merging composites.
 */
export declare type CompositeInput = Composite | CompositeParams;
/**
 * Supported options for merging composites.
 */
export declare type CompositeOptions = {
    /**
     * Additional Models aliases merged in the composite in addition to the ones present in the
     * source composites.
     */
    aliases?: Record<string, string>;
    /**
     * Behavior to apply for merging common embeds:
     * - `none` (default) will not set an common embed
     * - `all` will merge all the common embeds found in any composite
     * - explicit embed names to set as common embeds
     */
    commonEmbeds?: 'all' | 'none' | Iterable<string>;
    /**
     * Additional views merged in the composite in addition to the ones present in the source
     * composites.
     */
    views?: CompositeViewsDefinition;
};
/**
 * Composite creation parameters from a schema.
 */
export declare type CreateParams = {
    /**
     * Ceramic instance connected to the node the new Model streams must be created on. The Ceramic
     * instance **must have an authenticated DID attached to it** in order to create Models, using
     * the `did:key` method.
     */
    ceramic: CeramicApi;
    /**
     * Composite schema string.
     */
    schema: string;
    /**
     * Whether to add the Models to the index or not. If `true` (default), the Ceramic instance
     * must be authenticated with an admin DID.
     */
    index?: boolean;
};
/**
 * Composite creation parameters from a JSON-encoded definition.
 */
export declare type FromJSONParams = {
    /**
     * Ceramic instance connected to the node where the Model stream will be pushed.
     */
    ceramic: CeramicApi;
    /**
     * JSON-encoded composite definition.
     */
    definition: EncodedCompositeDefinition;
    /**
     * Whether to add the Models to the index or not. If `true`, the Ceramic instance must be
     * authenticated with an admin DID. Defaults to `false`.
     */
    index?: boolean;
};
/**
 * Composite creation parameters from existing models.
 */
export declare type FromModelsParams = CompositeOptions & {
    /**
     * Ceramic instance connected to the node where the Model stream are already present.
     */
    ceramic: CeramicApi;
    /**
     * Stream IDs of the Models to import in the composite.
     */
    models: Array<string>;
    /**
     * Whether to add the Models to the index or not. If `true`, the Ceramic instance must be
     * authenticated with an admin DID. Defaults to `false`.
     */
    index?: boolean;
};
/**
 * The Composite class provides APIs for managing composites (sets of Model streams) through their
 * development lifecycle, including the creation of new Models, import and export of existing
 * composites encoded as JSON, and compilation to the runtime format used by the
 * {@linkcode client.ComposeClient ComposeClient class}.
 *
 * Composite instances are **immutable**, so methods affecting the contents of the internal
 * composite definition will **return new instances** of the Composite class.
 *
 * Composite class is exported by the {@linkcode devtools} module.
 *
 * ```sh
 * import { Composite } from '@composedb/devtools'
 * ```
 */
export declare class Composite {
    #private;
    /**
     * Current version of the composites format.
     */
    static VERSION: string;
    /**
     * Create new model streams based on the provided `schema` and group them in a composite
     * wrapped in a Composite instance.
     */
    static create(params: CreateParams): Promise<Composite>;
    /**
     * Create a Composite instance by merging existing composites.
     */
    static from(composites: Iterable<CompositeInput>, options?: CompositeOptions): Composite;
    /**
     * Create a Composite instance from a JSON-encoded `CompositeDefinition`.
     */
    static fromJSON(params: FromJSONParams): Promise<Composite>;
    /**
     * Create a Composite instance from a set of Model streams already present on a Ceramic node.
     */
    static fromModels(params: FromModelsParams): Promise<Composite>;
    constructor(params: CompositeParams);
    /**
     * Stable hash of the internal definition, mostly used for comparisons.
     */
    get hash(): string;
    /**
     * StreamID of the Models used in the Composite.
     */
    get modelIDs(): Array<string>;
    /**
     * Copy a given set of Models identified by their stream ID, name or alias into a new Composite.
     */
    copy(models: Array<string>): Composite;
    /**
     * Check if the composite is equal to the other one provided as input.
     */
    equals(other: CompositeInput): boolean;
    /**
     * Merge the composite with the other one(s) into a new Composite.
     */
    merge(other: CompositeInput | Array<CompositeInput>, options?: CompositeOptions): Composite;
    /**
     * Set aliases for the Models in the composite, merging with existing ones unless `replace` is
     * `true`, and return a new Composite.
     */
    setAliases(aliases: Record<string, string>, replace?: boolean): Composite;
    /**
     * Set common embeds for the Models in the composite, merging with existing ones unless `replace`
     * is `true`, and return a new Composite.
     */
    setCommonEmbeds(names: Iterable<string>, replace?: boolean): Composite;
    /**
     * Set views for the Models in the composite, merging with existing ones unless `replace` is
     * `true`, and return a new Composite.
     */
    setViews(views: CompositeViewsDefinition, replace?: boolean): Composite;
    /**
     * Configure the Ceramic node to index the models defined in the composite. An authenticated DID
     * set as admin in the Ceramic node configuration must be attached to the Ceramic instance.
     */
    startIndexingOn(ceramic: CeramicApi): Promise<void>;
    /**
     * Return a JSON-encoded `CompositeDefinition` structure that can be shared and reused.
     */
    toJSON(): EncodedCompositeDefinition;
    /**
     * Return a deep clone of the internal {@linkcode CompositeParams} for safe external access.
     */
    toParams(): CompositeParams;
    /**
     * Return a `RuntimeCompositeDefinition` to be used at runtime by the
     * {@linkcode client.ComposeClient ComposeClient}.
     */
    toRuntime(): RuntimeCompositeDefinition;
}
export {};
